# Задача 1:  Долой Python! Да здравствует NumPy!

В этом задании вам будут предложены реализации некоторых функций на Python. Ваша задача - векторизовать код этих функций, используя NumPy.

### Часть 1. Сложение массивов

**Условие:**  
Векторизуйте код функции `sum_arrays_naive`.

**Python функция**:
```python
def sum_arrays_naive(
    lhs: list[float],
    rhs: list[float],
) -> list[float]:
    if len(lhs) != len(rhs):
        raise ShapeMismatchError
    
    return [
        elem_lhs + elem_rhs for elem_lhs, elem_rhs in zip(lhs, rhs)
    ]
```

Допишите код векторизованной функции в файле [task1](../solutions/sem02/lesson03/task1.py).

**Входные данные:**  
- `lhs` - одномерный массив чисел с плавающей точкой;
- `rhs` - одномерный массив чисел с плавающей точкой;

**Выходные данные:**  
- Одномерный массив, элементы которого - суммы соответствующих элементов входных массивов. 

**Сторонние эффекты**:
- Если входные массивы `rhs` и `lhs` имеют разное число элементов, необходимо возбудить исключение `ShapeMismatchError`.

### Часть 2. Полиномы

Векторизуйте код функции `compute_poly_naive`.

**Python функция**:
```python
def compute_poly_naive(abscissa: list[float]) -> list[float]:
    return [3 * (x ** 2) + 2 * x + 1 for x in abscissa]
```
Допишите код векторизованной функции в файле [task1](../solutions/sem02/lesson03/task1.py).

**Входные данные:**  
- `abscissa` - одномерный массив чисел с плавающей точкой - область определения для вычисления полинома;

**Выходные данные:**  
- Одномерный массив, элементы которого - значения полинома $y = 3 x^2 + 2x + 1$.

### Часть 3. Далеко ли, близко ли?

Векторизуйте код функции `get_mutual_l2_distances_naive`.

Допишите код векторизованной функции в файле [task1](../solutions/sem02/lesson03/task1.py).

**Python функция**:
```python
def get_mutual_l2_distances_naive(
    lhs: list[list[float]],
    rhs: list[list[float]],
) -> list[list[float]]:    
    if len(lhs[0]) != len(rhs[0]):
        raise ShapeMismatchError
    
    return [
        [
            sum(
                (lhs[i][k] - rhs[j][k]) ** 2 for k in range(len(lhs[0]))
            ) ** 0.5
            for j in range(len(rhs))
        ]
        for i in range(len(lhs))
    ]
```

**Входные данные**:
- `lhs` - двумерный массив чисел с плавающей точкой;
- `rhs` - двумерный массив чисел с плавающей точкой;

**Выходные данные**:
- Двумерный массив. Элемент `[i][j]` двумерного массива соответствует евклидову расстоянию между `i`-ым вектором из массива `lhs` и `j`-ым вектором из массива `rhs`. Под векторами подразумеваем строки входных двумерных массивов.

**Сторонние эффекты**:
- Если входные массивы `rhs` и `lhs` имеют разное число колонок, необходимо возбудить исключение `ShapeMismatchError`.

## Задача 2. Сферические координаты: туда и обратно

Необходимо реализовать две функции: функцию перевода координат из трехмерной прямоугольной декартовой системы координат в сферические координаты и функцию перевода из сферических координат в трехмерную прямоугольную сферическую систему координат.

### Перевод из декартовых координат в сферические

Допишите код функции `convert_from_sphere` в файле [task2](../solutions/sem02/lesson03/task2.py).

**Входные данные**:
- `abscissa` - np.ndarray, абсциссы точек;
- `ordinates` - np.ndarray, ординаты точек;
- `applicates` - np.ndarray, аппликаты точек;

**Выходные данные**:
- Кортеж (`tuple`) из трех элементов, каждый элемент - np.ndarray. Первый элемент `tuple` - массив расстояний, второй элемент `tuple` - массив углов в диапазоне от $[-\pi, \pi]$ - углы азимута, третий элемент `tuple` - массив углов в диапазоне от $[-\pi, \pi]$ - углы места.

**Сторонние эффекты**:
- Если количество элементов во входных массивах `abscissa`, `ordinates` и `applicates` отличаются, необходимо возбудить исключение `ShapeMismatchError`.

*Замечания*:
- Гарантируется, что на вход подаются непустые одномерные массивы чисел с плавающей точкой.
- Предполагаем, что для перевода в сферические координаты используются следующие формулы:
    $$x = r*sin(\theta)*cos(\phi); y = r*sin(\theta)*sin(\phi);z = r*cos(\theta)$$

### Перевод из сферических координат в декартовы

Допишите код функции `convert_to_sphere` в файле [task2](../solutions/sem02/lesson03/task2.py).

**Входные данные**:
- `distances` - np.ndarray, массив расстояний;
- `azimuth` - np.ndarray, массив углов азимута в диапазоне $[-\pi, \pi]$;
- `inclination` - np.ndarray, массив углов места в диапазоне $[-\pi, \pi]$

**Выходные данные**:
- Кортеж (`tuple`) из трех элементов, каждый элемент - np.ndarray. Первый элемент `tuple` - массив абсцисс, второй элемент `tuple` - массив ординат, третий элемент `tuple` - массив аппликат.

**Сторонние эффекты**:
- Если количество элементов во входных массивов `distances`, `azimuth` и `inclination` отличаются, необходимо возбудить исключение `ShapeMismatchError`.

## Задача 3. Низины и возвышенности

На вход подается одномерный массив чисел с плавающей точкой - значения некоторой функции на определенном отрезке. Ваша задача - вычислить индексы элементов, соответствующие точкам экстремума данной функции.

Допишите код в файле [task3](../solutions/sem02/lesson03/task3.py).

**Входные данные**:
- `ordinates` - np.ndarray числе с плавающей точкой, значения некоторой функции на определенном отрезке;

**Выходные данные**:
- Кортеж (`tuple`) из двух элементов. Элементы кортежа - np.ndarray. Первый элемент - индексы точек минимум, второй элемент - индексы точек максимума;

**Сторонние эффекты**:
- Если в массиве `ordinates` содержится менее трех элементов, необходимо возбудить `ValueError`.

*Замечение*:
- Краевые точки не принимают участия в вычислениях. Т.е. элементы с индексами 0 и -1 не могут быть точками экстремума.
